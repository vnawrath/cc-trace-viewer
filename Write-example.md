# Input

```json
{
  "file_path": "/Users/viktornawrath/repos/cc-trace-viewer/src/hooks/useVirtualization.ts",
  "content": "import { useState, useEffect, useRef, useMemo } from 'react';\n\nexport interface VirtualizationOptions {\n  itemHeight: number;\n  containerHeight: number;\n  overscan?: number;\n}\n\nexport interface VirtualizedItem {\n  index: number;\n  start: number;\n  end: number;\n}\n\nexport function useVirtualization<T>(\n  items: T[],\n  options: VirtualizationOptions\n) {\n  const [scrollTop, setScrollTop] = useState(0);\n  const scrollElementRef = useRef<HTMLDivElement>(null);\n\n  const { itemHeight, containerHeight, overscan = 5 } = options;\n\n  const visibleRange = useMemo(() => {\n    const start = Math.floor(scrollTop / itemHeight);\n    const end = Math.min(\n      start + Math.ceil(containerHeight / itemHeight),\n      items.length - 1\n    );\n\n    const overscanStart = Math.max(0, start - overscan);\n    const overscanEnd = Math.min(items.length - 1, end + overscan);\n\n    return {\n      start: overscanStart,\n      end: overscanEnd,\n      visibleStart: start,\n      visibleEnd: end\n    };\n  }, [scrollTop, itemHeight, containerHeight, items.length, overscan]);\n\n  const virtualizedItems = useMemo(() => {\n    const result: Array<VirtualizedItem & { data: T }> = [];\n\n    for (let i = visibleRange.start; i <= visibleRange.end; i++) {\n      result.push({\n        index: i,\n        start: i * itemHeight,\n        end: (i + 1) * itemHeight,\n        data: items[i]\n      });\n    }\n\n    return result;\n  }, [items, visibleRange, itemHeight]);\n\n  const totalHeight = items.length * itemHeight;\n\n  const handleScroll = (e: React.UIEvent<HTMLDivElement>) => {\n    setScrollTop(e.currentTarget.scrollTop);\n  };\n\n  return {\n    virtualizedItems,\n    totalHeight,\n    visibleRange,\n    handleScroll,\n    scrollElementRef\n  };\n}\n\n// Hook for pagination with search/filter support\nexport function usePagination<T>(\n  items: T[],\n  pageSize: number = 50\n) {\n  const [currentPage, setCurrentPage] = useState(0);\n\n  const totalPages = Math.ceil(items.length / pageSize);\n\n  const paginatedItems = useMemo(() => {\n    const start = currentPage * pageSize;\n    const end = start + pageSize;\n    return items.slice(start, end);\n  }, [items, currentPage, pageSize]);\n\n  const goToPage = (page: number) => {\n    setCurrentPage(Math.max(0, Math.min(page, totalPages - 1)));\n  };\n\n  const goToNextPage = () => goToPage(currentPage + 1);\n  const goToPrevPage = () => goToPage(currentPage - 1);\n\n  // Reset to first page when items change\n  useEffect(() => {\n    setCurrentPage(0);\n  }, [items.length]);\n\n  return {\n    currentPage,\n    totalPages,\n    paginatedItems,\n    pageSize,\n    goToPage,\n    goToNextPage,\n    goToPrevPage,\n    hasNextPage: currentPage < totalPages - 1,\n    hasPrevPage: currentPage > 0\n  };\n}\n\n// Hook for lazy loading with intersection observer\nexport function useLazyLoading(\n  loadMore: () => void,\n  hasMore: boolean,\n  threshold: number = 0.1\n) {\n  const [loading, setLoading] = useState(false);\n  const observerRef = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    const observer = new IntersectionObserver(\n      ([entry]) => {\n        if (entry.isIntersecting && hasMore && !loading) {\n          setLoading(true);\n          loadMore();\n          setTimeout(() => setLoading(false), 100); // Prevent rapid fire\n        }\n      },\n      { threshold }\n    );\n\n    const currentRef = observerRef.current;\n    if (currentRef) {\n      observer.observe(currentRef);\n    }\n\n    return () => {\n      if (currentRef) {\n        observer.unobserve(currentRef);\n      }\n    };\n  }, [loadMore, hasMore, loading, threshold]);\n\n  return { observerRef, loading };\n}\n\n// Debounced search hook\nexport function useDebouncedSearch(\n  searchTerm: string,\n  delay: number = 300\n) {\n  const [debouncedValue, setDebouncedValue] = useState(searchTerm);\n\n  useEffect(() => {\n    const handler = setTimeout(() => {\n      setDebouncedValue(searchTerm);\n    }, delay);\n\n    return () => clearTimeout(handler);\n  }, [searchTerm, delay]);\n\n  return debouncedValue;\n}\n\n// Memory usage monitoring hook\nexport function useMemoryMonitor() {\n  const [memoryInfo, setMemoryInfo] = useState<{\n    usedJSHeapSize: number;\n    totalJSHeapSize: number;\n    jsHeapSizeLimit: number;\n    percentage: number;\n  } | null>(null);\n\n  useEffect(() => {\n    if ('memory' in performance) {\n      const updateMemoryInfo = () => {\n        const memory = (performance as any).memory;\n        setMemoryInfo({\n          usedJSHeapSize: memory.usedJSHeapSize,\n          totalJSHeapSize: memory.totalJSHeapSize,\n          jsHeapSizeLimit: memory.jsHeapSizeLimit,\n          percentage: (memory.usedJSHeapSize / memory.jsHeapSizeLimit) * 100\n        });\n      };\n\n      updateMemoryInfo();\n      const interval = setInterval(updateMemoryInfo, 5000);\n\n      return () => clearInterval(interval);\n    }\n  }, []);\n\n  return memoryInfo;\n}"
}
```

# Output

```
File created successfully at: /Users/viktornawrath/repos/cc-trace-viewer/src/hooks/useVirtualization.ts
```
